//Difference entre un directory et une chaine random pour >

ls $HOME>> cava 	insere le resultat de ls dans le fichier cava
ls TODO>> cava 		insere "TODO" (str random) dans le fichier cava
ls $hello>> cava 	insere hello=TODO (str random) dans le fichier cava 

Je pense qu'il suffit simplement d'integrer la forme expand de $HOME de $hello et TODO
en arg dans execve et ls se charge du reste

//Difference entre un directory et une chaine random pour <
ls $HOME< cava stdin est redirige vers cava. ls tente de lire
dans $HELLO (format expand), s'il peut alors pas de message d'erreur
et ls affiche "TODO"

//Autre
Que se passe t il si le user fait Ctrl+D dans un heredoc non fermé. Bash semble renvoyer :
bash: warning: here-document at line [XXX] delimited by end-of-file (wanted `[le mot en question]')

//A gerer en priorité

- Gerer les unclosed brackets (voir bloc note sur telephone)

GOOD TO KMOW :
- Si le delim contient des quotes alors on n'expand pas les var d'env contenus dans le fichier tmp.txt.
- Si le delim est une var d'env (ex. $HOME) et que j'ecris $HOME dans le fichier alors ca le ferme et ca n'ecrit pas la valeur expand de $HOME
- Refuser un delim avec des quotes ouvertes (c'est deja prevu dans le parsing)

- Dire a Erika de retirer '>&' parmi les cas a gerer, car on va simplement le traiter comme une chaine classique (une valeur litterale)
- Quand je provoque une boucle infinie alors minishell casse. Il faudrait voir si le pb est decelable en correction, et si oui comment gerer
les signaux et eviter ce pb.

- Aller chercher les cas d'erreur a gerer par mail



- ni ls | |     ni ls | ls |      ni   | ls | ls  ne donne de resultat (ca renvoie juste une erreur). Genre rien du tout pas meme les enfants qui fonctionne.
Donc je pense que si le user oublie d'entrer qqchose entre des pipes (ou entre 1 pipe et le debut/la fin de la chaine) alors on renvoie
syntax error near unexpected token `|'
A la limite je peux laisser Erika gerer ca avec le debut de fonction qu'elle avait faite, où elle disait que si y'a 2 pipes cote a cote alors on renvoie l'erreur.
---------------



- si j'ecris : < $a    OU > $a        avec $a vide/inexistant alors bash retourne : $a: ambiguous redirect
Ca ne retourne pas syntax error near unexpected token `newline' comme le ferait un simple < ou un simple >. (Quid de >> ??)
Autrement dit bash crame que ca va pas s'expand et vu que c'est apres un <, il le garde et dit que ca pose pb
maintenant si j'assigne à a="file1 file2"   puis que je fais < $a alors j'ai bien file1 file2: No such file or directory.
Idem pour >, j'obtiens la creation d'un fichier nommé "file1 file2".

Voici comment je compte gérer le truc dans ft_expand :
    if (!envv)
        return (ft_erase_substr(result, k, tmp));//Ici il faudrait parcourir en arriere result pour voir si ce qui precede c'est un <.
	//Si c'est le cas alors on a l'erreur ambiguous ambiguous redirect et l'enfant ne s'active plus.

!!!
On peut sinon aussi gérer ce cas dans ft_ifexpand en dessous du cas pour <<.
!!!
Avec un truc du style (dans une fct dédiée qui recupere result, &k, sq, dq):

if (!sq && !dq && (!ft_strncmp(result + k, "< ", 2) 
	|| !ft_strncmp(result + k, "> ", 2) || !ft_strncmp(result + k, ">> ", 2)))
{
	int pos;
	char *name;

	if (!ft_strncmp(result + k, ">> ", 2))
		k += 2;
	else
		k++;
	while (result[k] == ' ')
		k++;
	pos = k;
	//on recupere le nom dans une chaine de caractere via une fonction dédiée
	name = ft_trunc(result, pos);
	if (result[k] == '$' && !sq
		&& (result[k + 1] == '_' || ft_isalnum(result[k + 1]) || result[k + 1] == '?'))
		ft_expand(ft_erase(result, k), &k);
	//Si l'expansion a foiré alors ca veut dire qu'on a pas bougé dans result et donc :
	if (pos == k)
	{
		//dans le tableau des erreurs on ecrit l'erreur (ambiguous redirect). 
		//On supprime tout l'enfant ? en effet il ne sera pas exécuté par bash.
	}
}


Je pense qu'il faut un tableau de suivi des erreurs qu'Erika va pouvoir incorporer et manipuler.
Comme ca meme si je supprime des enfants elle sait où remplir quoi.. Ca devrait meme etre un tableau de tableau de chaines de caracteres
car parfois un meme enfant renvoie plusieurs erreurs :
si je dis que a="bonjour ca va" et que je lance 
ls $a
ls: cannot access 'bonjour': No such file or directory
ls: cannot access 'ca': No such file or directory
ls: cannot access 'va': No such file or directory

---

en revanche si j'ecris juste $a dans le terminal alors j'obtiens : file1: command not found
C'est dû au fait qu'une commande bash ne peut pas contenir d'espace donc il créé 2 tokens et vu que le 1er n'existe pas il affiche que ca n'existe
pas et s'arrete la.
Il en est de meme pour une option.


NB : ce qui est marrant c'est que si a="oui( petit test)" et que je fais ls $a j'obtiens :
ls: cannot access 'oui(': No such file or directory
ls: cannot access 'petit': No such file or directory
ls: cannot access 'test)': No such file or directory

alors que si j'ecris directement dans le terminal ls "oui( petit test)" j'obtiens :
ls: cannot access 'oui( petit test)': No such file or directory

Ca confirme bien que l'expansion d'une commande ou une option se fait en plusieurs tokens separés par des espaces, et notre code
fonctionne deja tres bien si cette cmd ou option est entrée directement par le user.

CA fonctione tres bien si j'ecris A="PETIT TEST" alors PETIT et TEST seront decoupe correctement.
En revanche si j'ecris A="'PETIT TEST'" alors mon ft_split va le gérer comme un seul morceau alors que dans bash
il les coupe.






ATTENTION : il faudrait gérer aussi les cas où le user s'amuse à entrer $'hello' ce qui renvoie 'hello'.
Y'a un petit souci avec ca, c'est que si le user ecrit "$'hello'" alors bash renvoie $'hello': command not found (comme nous).
Maintenant si le user entre $'hello' alors ca renvoie 'hello': command not found.
Dans ft_concat a la toute fin de la fonction, il faut simplement faire en sorte que si on est hors de quote, et qu'on croise une quote
mais qu'elle suit un $ alors on erase juste le dollar.
On pourrait par exemple modifier le 1er if dans la boucle while :

	while (result_i[++k])
	{
		if (result_i[k] == result_i[to_erase])
		{
			is_concat = 1;
			///////////////////////////
			if (result_i[to_erase - 1] == '$')
				ft_erase(result_i, to_erase - 1);
			else
				ft_erase(result_i, to_erase);
			k--;
			ft_erase(result_i, k);
			k--;
			while (result_i[++k] && !(result_i[k] == '\''
					|| result_i[k] == '\"'))
			if (!result_i[k])
				return (result_i);
			to_erase = k;
		}
	}


SINON on créé une fonction edge_case dans la boucle while : si en k - 1 j'ai un $ et qu'en k j'ai un quote et que juste avant la fin
de  la chaine j'ai un quote du meme type alors je erase juste le dollar et je me casse. Mais meme ps sur que ca marcherait
pour les cas du style $'"'hello'"'