A CHECKER :
- gestion des signaux dans le heredoc (que pasa si on fait ctrl+c et ctrl+d)
- ATTENTION si le delimiteur comporte des quote alors les variables d'environnement ne s'expand pas,
sinon on utilise une version basique de ft_ifexpand sur chaque newline de heredoc.
- ATTENTION a l'ordre d'execution et a la recuperation de resultats si je fais plusieurs heredoc a la fois
: << $HELLO ls | ls << $CAVA       il faut ici fermer les 2 heredoc avant d'afficher le resultat
- Erika sait elle gerer ls | < $HOME cad un enfant qui n'a pas de cmd ?
- Attention comment Erika gere le heredoc. Il faut d'abord le faire avant de lancer la commande associee je crois (redemander a Mabrouk)
- proteger notre minishell pour eviter les leaks avec ulimit. Proteger les fork pour eviter les leaks lorsque je lance une commande
- Si je fais un Shift + Enter (introduction de \n) alors ca segfault. Pas un souci car dans bash je peux faire Shift + Enter uniquement apres un | ou heredoc
Par ailleurs en bash il est impossible de mettre un dollar suivi de \n

//Autre
Que se passe t il si le user fait Ctrl+D dans un heredoc non fermé. Bash semble renvoyer :
bash: warning: here-document at line [XXX] delimited by end-of-file (wanted `[le mot en question]')

GOOD TO KMOW :
- Si le delim contient des quotes alors on n'expand pas les var d'env contenus dans le fichier tmp.txt.
- Si le delim est une var d'env (ex. $HOME) et que j'ecris $HOME dans le fichier alors ca le ferme et ca n'ecrit pas la valeur expand de $HOME
- Refuser un delim avec des quotes ouvertes (c'est deja prevu dans le parsing)

- Dire a Erika de retirer '>&' parmi les cas a gerer, car on va simplement le traiter comme une chaine classique (une valeur litterale)
- Quand je provoque une boucle infinie alors minishell casse. Il faudrait voir si le pb est decelable en correction, et si oui comment gerer
les signaux et eviter ce pb.

- Aller chercher les cas d'erreur a gerer par mail

Si j'assigne à a="file1 file2"   puis que je fais < $a alors j'ai file1 file2: No such file or directory.
Idem pour >, j'obtiens la creation d'un fichier nommé "file1 file2".

Si je dis que a="bonjour ca va" et que je lance 
ls $a
ls: cannot access 'bonjour': No such file or directory
ls: cannot access 'ca': No such file or directory
ls: cannot access 'va': No such file or directory

NB : si a="oui' petit test'" et que je fais ls $a j'obtiens :
ls: cannot access 'oui'': No such file or directory
ls: cannot access 'petit': No such file or directory
ls: cannot access 'test'': No such file or directory

























//zzzyzz' ='"boloss"       donne      `zzzyzz =boloss': not a valid identifier        En gros peut pas y avoir d'espace entre le nom et le '=' (apres concatenation).
//Il faut faut faire un parser pour gerer tous ces cas. Autre cas impossible : le nom de la variable ne peut pas commencer par =. Exemple "="hello=5.
//. ne peut pas etre present dans le name.

//De facon general il faut bien faire gaffe au comportement de minishell si le user s'amuse a mettre les options n'importe ou dans cmds[i]
int   ft_exparser(char *name_key)
{
    int i;

    if ((name_key[0] >= '0' && name_key[0] <= '9') || name_key[i] == '=')
    {
        //(il faudrait remplir le meme ft_write que ce qu'il y en dessous ?)
        printf("export:t'as mis un numerique en pos 0\n");
        return (1);
    }
    i = -1;
    while (name_key[++i])
    {
        //C'est cense gerer le cas ou name vaut \0 et le cas ou name commence par '='
        //if (!(ft_isalnum(name_key[i]) || name_key[i] == '_'))
        if (!(ft_isalnum(name_key[i])
            || name_key[i] == '_' || name_key[i] == '='))
        {
            //(il faudrait remplir le meme ft_write que ce qu'il y a dessus ?)
            printf("export: `name=key': not a valid identifier\n");
            return (1);
        }
        if (name_key[i] == '=')
            break;
    }
    return (0);
}