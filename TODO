A CHECKER :
- gestion des signaux dans le heredoc (que pasa si on fait ctrl+c et ctrl+d)
- ATTENTION si le delimiteur comporte des quote alors les variables d'environnement ne s'expand pas,
sinon on utilise une version basique de ft_ifexpand sur chaque newline de heredoc.
- ATTENTION a l'ordre d'execution et a la recuperation de resultats si je fais plusieurs heredoc a la fois
: << $HELLO ls | ls << $CAVA       il faut ici fermer les 2 heredoc avant d'afficher le resultat
- Erika sait elle gerer ls | < $HOME cad un enfant qui n'a pas de cmd ?
- Attention comment Erika gere le heredoc. Il faut d'abord le faire avant de lancer la commande associee je crois (redemander a Mabrouk)
- proteger notre minishell pour eviter les leaks avec ulimit. Proteger les fork pour eviter les leaks lorsque je lance une commande
- Si je fais un Shift + Enter (introduction de \n) alors ca segfault. Pas un souci car dans bash je peux faire Shift + Enter uniquement apres un | ou heredoc
Par ailleurs en bash il est impossible de mettre un dollar suivi de \n

//Autre
Que se passe t il si le user fait Ctrl+D dans un heredoc non fermé. Bash semble renvoyer :
bash: warning: here-document at line [XXX] delimited by end-of-file (wanted `[le mot en question]')

GOOD TO KMOW :
- Si le delim contient des quotes alors on n'expand pas les var d'env contenus dans le fichier tmp.txt.
- Si le delim est une var d'env (ex. $HOME) et que j'ecris $HOME dans le fichier alors ca le ferme et ca n'ecrit pas la valeur expand de $HOME
- Refuser un delim avec des quotes ouvertes (c'est deja prevu dans le parsing)

- Dire a Erika de retirer '>&' parmi les cas a gerer, car on va simplement le traiter comme une chaine classique (une valeur litterale)
- Quand je provoque une boucle infinie alors minishell casse. Il faudrait voir si le pb est decelable en correction, et si oui comment gerer
les signaux et eviter ce pb.

- Aller chercher les cas d'erreur a gerer par mail

Si j'assigne à a="file1 file2"   puis que je fais < $a alors j'ai file1 file2: No such file or directory.
Idem pour >, j'obtiens la creation d'un fichier nommé "file1 file2".

Si je dis que a="bonjour ca va" et que je lance 
ls $a
ls: cannot access 'bonjour': No such file or directory
ls: cannot access 'ca': No such file or directory
ls: cannot access 'va': No such file or directory

NB : si a="oui' petit test'" et que je fais ls $a j'obtiens :
ls: cannot access 'oui'': No such file or directory
ls: cannot access 'petit': No such file or directory
ls: cannot access 'test'': No such file or directory

















int   ft_exparser(char *name_key)
{
    int i;

    i = -1;
    while (name_key[++i])
    {
        //Si en i j'ai un alnum ou _, qu'en i + 1 j'ai un '+' et qu'en i + 2 j'ai un '=' alors je mets ma dummy a 1
        //et dans addenvnode on fera une concatenation.


        //C'est cense gerer le cas ou name vaut \0 et le cas ou name commence par '='.
        //ca gere aussi le cas ou un espace est avant le = puisqu'on teste le if en dessous jusqu'au '='.
        // if (!(ft_isalnum(name_key[i]) || name_key[i] == '_'))
        if (!ft_isalnum(name_key[i]) && name_key[i] != '_')
        {
            //(il faudrait remplir le meme ft_write que ce qu'il y a dessus ?)
            printf("export: `name=key': not a valid identifier\n");
            return (1);
        }
        if (name_key[i] == '=')
            break;
    }
    return (0);
}















static char **ft_export(char **env, char **argv)
{
    // Gerer le cas ou env est NULL : env -i ./minishell (voir bloc note)
    t_env *head;
    char  **adder;
    int   i;

    head = NULL;
    i = -1;
    while (env[++i])
        ft_adder(&head, env[i]);
    if (!argv)//Ou plutot !argv[1] dans le code final ?
        return (ft_bbsort(head), ft_printexport(head), ft_freelexport(head), NULL);//gc_cleaner ?

    //Le parser arrive ici ! argv[1][0] = export a priori
    //cmds[0] = export, cmds[1] = premier truc apres export. Hors l'option ne peut que se situer la.
    if (argv[1][0] == '-')
    {
        //Si le user entre une option d'apres le sujet on ne traite plus rien
        printf("export: No option(s) allowed\n");//ft_write
        ft_freelexport(head);//gc_cleaner
        exit(2);//quel code d'erreur mettre ? 2 : arbitraire
    }
    i = 0;//car argv[0] est le nom du prg?? Il faut mettre -1 ? Pas sur
    while (argv[++i])
    {
        //MARCHE PAS JE PENSE QUE J'AI MAL FAIT MA CONDITION DANS env_manager.c
        if (!ft_exparser(argv[i]))
            ft_adder(&head, argv[i]);
    }
    //////////////
    // i = 0;//car argv[0] est le nom du prg, mais a voir si c adapte au code final. Il faudra le changer quand on passera a cmd[i] !!!!!!!
    // //Ah non en fait pas sur puisque cmd[0] sera egal a "export"
    // while (argv[++i])
    //     ft_adder(&head, argv[i]);


    adder = ft_ltoa(head);
    ft_printexport(head);
    ft_freelexport(head);
    //Retirer la variable _ dans la structure env de minishell
    //(ca n'apparait pas dans bash --posix) ??
    //Sur ?? Car ca apparait dans bash --posix
    return (adder);
}