//Difference entre un directory et une chaine random pour >

ls $HOME>> cava 	insere le resultat de ls dans le fichier cava
ls TODO>> cava 		insere "TODO" (str random) dans le fichier cava
ls $hello>> cava 	insere hello=TODO (str random) dans le fichier cava 

CONCLUSION : le directory est integre dans ls je pense. Ensuite ca recupere
le dernier truc (resultat ls) et ca l'integre dans cava

A CHECKER :
- gestion des signaux dans le heredoc (que pasa si on fait ctrl+c et ctrl+d)
- ATTENTION si le delimiteur comporte des quote alors les variables d'environnement ne s'expand pas,
sinon on utilise une version basique de ft_ifexpand sur chaque newline de heredoc.
- ATTENTION a l'ordre d'execution et a la recuperation de resultats si je fais plusieurs heredoc a la fois
: << $HELLO ls | ls << $CAVA       il faut ici fermer les 2 heredoc avant d'afficher le resultat
- Erika sait elle gerer ls | < $HOME cad un enfant qui n'a pas de cmd ?
- Attention comment Erika gere le heredoc. Il faut d'abord le faire avant de lancer la commande associee je crois (redemander a Mabrouk)
- proteger notre minishell pour eviter les leaks avec ulimit. Proteger les fork pour eviter les leaks lorsque je lance une commande
- Si je fais un Shift + Enter (introduction de \n) alors ca segfault. Pas un souci car dans bash je peux faire Shift + Enter uniquement apres un | ou heredoc
Par ailleurs en bash il est impossible de mettre un dollar suivi de \n

//Autre
Que se passe t il si le user fait Ctrl+D dans un heredoc non fermé. Bash semble renvoyer :
bash: warning: here-document at line [XXX] delimited by end-of-file (wanted `[le mot en question]')

GOOD TO KMOW :
- Si le delim contient des quotes alors on n'expand pas les var d'env contenus dans le fichier tmp.txt.
- Si le delim est une var d'env (ex. $HOME) et que j'ecris $HOME dans le fichier alors ca le ferme et ca n'ecrit pas la valeur expand de $HOME
- Refuser un delim avec des quotes ouvertes (c'est deja prevu dans le parsing)

- Dire a Erika de retirer '>&' parmi les cas a gerer, car on va simplement le traiter comme une chaine classique (une valeur litterale)
- Quand je provoque une boucle infinie alors minishell casse. Il faudrait voir si le pb est decelable en correction, et si oui comment gerer
les signaux et eviter ce pb.

- Aller chercher les cas d'erreur a gerer par mail

Si j'assigne à a="file1 file2"   puis que je fais < $a alors j'ai file1 file2: No such file or directory.
Idem pour >, j'obtiens la creation d'un fichier nommé "file1 file2".

Si je dis que a="bonjour ca va" et que je lance 
ls $a
ls: cannot access 'bonjour': No such file or directory
ls: cannot access 'ca': No such file or directory
ls: cannot access 'va': No such file or directory

NB : si a="oui' petit test'" et que je fais ls $a j'obtiens :
ls: cannot access 'oui'': No such file or directory
ls: cannot access 'petit': No such file or directory
ls: cannot access 'test'': No such file or directory